{"data":[{"title":"404 Not Found","url":"/404.html","content":"\n    \n\n\n\n    Image from http.cat.\n\n"},{"title":"About","url":"/about/","content":"\n\n\nAbout Me\n\n学生党, 新鲜韭菜, 野生Arch Linux用户一枚\n\n咱喜欢的游戏: Minecraft Java Edition, NieR:Automata, NieR:Replicant, Detroit: Become Human, Portal全系列; 除此之外咱还玩过Overwatch, PUBG, FGO, Don't Starve, 崩坏3等。\n\n咱喜欢的动漫/电影: 空之境界剧场版（推荐空境原著）、FSN &amp; FZ全系列、某科学的超电磁炮、君主·埃尔梅罗二世事件簿 魔眼收集列车 Grace note、声之形、秒速5厘米、利兹与青鸟、狼与香辛料。\n还看过格莱普尼尔、黑执事、几集新世纪福音战士和宝石之国和魔法禁书目录、我们从未知道那天所见的花的名字等。\n\n月厨, 空境剧场版看过无数遍, 原著看过一次后打算有时间再看一遍, 第一次读原著好多东西都没有看懂, FGO玩不懂算是个假月厨吧。\n\n咱喜欢摄影，有一台入门级半画幅单反，适马17-50mm f2.8和佳能50mm f1.8镜头。\n\n听歌种类略杂, 很少听华语。喜欢的歌以ACG系列为主, 首选Kalafina和梶浦由記的曲子以及尼尔/龙背系列。尽管不是东方厨但是东方的歌确实好听, 除此之外还听电音和轻音乐。\n\n常用Apple Music, 因为Apple Music有Kalafina的版权, 除此之外还经常用网易云音乐查找歌曲以及听日推\n\n偶尔在B站水视频, 是一名没有几个粉丝、几个月一更新的那种年更UP主, 不追求播放量和粉丝数,有人喜欢就很开心了。\n\n社交恐惧, 拖延, 情商低, 自我设障, 不过都太复杂了咱自己也讲不清楚（也不想弄清楚了, 不爱说话是真的\n\n不擅长交流，有些太复杂的东西又很难用文字表达出来\n\n不擅长制定并执行计划, 喜欢压力, 擅长拖延。\n\n菜, 很菜, 非常菜, 还懒, 不想努力, 肥, 宅, 新手, 不萌, 丑, 接近于废物一个。\n\n睡觉 睡觉 睡觉 睡觉 睡觉 睡觉 ZZZZZZZ~\n\n\nSTARRY-S' Blog\n建于2016年8月21日, 曾用域名starry-s.xyz、starry-s.com和starry-s.cn。\n现用域名为starry-s.me, 以后没问题的话就不打算换域名了因为.me域名好记而且我挺喜欢的。\n本站由Hikaru生成, 主题为ARIA, 托管于GitHub Pages（见页面右下角）, 很喜欢这个生成器以及ARIA这款主题。\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"尼尔机械纪元 Nier Automata - Soundtrack Medley\",\n        artist: \"Animenz\",\n        url: \"https://music.starry-s.me/music/0f0e_0758_070b_8de6859a81025aae1e540aed59439f48.m4a\",\n        cover: \"https://music.starry-s.me/music/cover/109951163092751719.jpg\",\n        lrc: \"\",\n        theme: \"#F6890E\"\n    }]\n});\n \n\n\n写于2020年8月16日凌晨, 随时更新。\n\n"},{"title":"归档","url":"/archives/","content":""},{"title":"分类","url":"/categories/","content":""},{"title":"首页","url":"/","content":""},{"title":"标签","url":"/tags/","content":""},{"title":"Learn OpenGL","url":"/posts/learn_opengl/","content":"\n\n其实咱很久很久以前就开始看LearnOpenGL CN这个网站了......\n\n\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"One Light\",\n        artist: \"Kalafina\",\n        url: \"https://music.starry-s.me/music/obj_w5rDlsOJwrLDjj7CmsOj_8776656540_d358_942f_cb9c_b29cfa734f2c6c5f95938d794ce3d90e.mov\",\n        cover: \"https://music.starry-s.me/music/cover/Kalafina All Time Best 2008-2018 small.jpg\",\n        lrc: \"\",\n        theme: \"#484444\"\n    }]\n});\n \n\n前言\n首先需要明白什么是核心模式，什么是立即渲染模式，立即渲染模式的代码中都包含glBegin()和glEnd()，绘图的部分都是在这两个函数之间，比如画一个点就是glVertex2f(x, y)，这种方式画图确实很简单，用户只要提供坐标和颜色就好了，不用知道GPU干了什么，而缺点是性能低，有很多限制，所以新版本的OpenGL为了给开发者提供更多的可操作空间而逐渐废弃了立即渲染改用核心模式。\n核心模式提供了很多强大的功能，可以管线编程，代码量增加了很多，所以对初学者不太友好。\nLearnOpenGL CN上面的代码基于C++，而OpenGL是用C编写的，教程上的代码除了矩阵运算部分可以使用C++的运算符重载而使代码编写起来变得更简单一些外，其他部分基本没啥区别，而且教程为了便于教学使用的也是面向过程式编程，没有将各个功能封装到一个类里面，所以咱这篇教程用C编写。\n要记住C就是C，C++就是C++，C不是C++的子集，只能说C++兼容部分C的代码，不要把C和C++混用，不要因为C++支持面向对象使得一些功能看起来简单很易于使用就轻易迈入C++的坑。\n准备工作\n有关OpenGL的介绍以及安装GLFW、GLAD以及编译所需的CMake的部分可以直接看教程，咱尽可能把教程上没有提到的或者是刚开始学OpenGL很难理解的部分记录下来。\n大体上就是安装glfw，Arch Linux使用包管理器sudo pacman -S glfw-x11 (如果你使用的是wayland，那么安装glfw-wayland)，然后把下载的glad/glad.h复制到/usr/include下，把glad.c复制到工程文件夹的代码目录下。\n为使用CMake生成Makefile，编写CMakeLists.txt:\ncmake_minimum_required(VERSION 3.0)\n\nproject(\n    \"Learn OpenGL\"\n    LANGUAGES C\n    VERSION 0.1.0\n)\n\nset(C_FLAGS \"-Wall -lm -ldl -std=c11\")\nset(CMAKE_C_FLAGS ${C_FLAGS})\nset(OpenGL_GL_PREFERENCE LEGACY)\n\nfind_package(glfw3 REQUIRED)\nfind_package(OpenGL REQUIRED)\n\ninclude_directories(${OPENGL_INCLUDE_DIR} src)\n\naux_source_directory(\"src\" GLSRC)\nadd_executable(main ${GLSRC})\ntarget_link_libraries(main ${OPENGL_gl_LIBRARY} glfw)\n\n完成上述步骤后，确保工程文件夹的结构如下：\n├── build/\n├── CMakeLists.txt\n└── src/\n    ├── glad.c\n    └── main.c\n\n创建窗口\n编辑main.c，加入所需的头文件\n\n#include \n#include \n\" data-info=\"language-C\" data-lang=\"C\" class=\"code-block\">// glad.h要加在glfw3.h之前\n\n#include &lt;glad/glad.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;stdio.h&gt;\n\n在main函数中初始化OpenGL并创建窗口\nint main(int argc, char **argv)\n{\n        glfwInit();\n        /* 使用OpenGL版本为3.3 */\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n        /* 使用核心模式 */\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n        /* 创建窗口 */\n        GLFWwindow *window =\n                    glfwCreateWindow(800, 600, \"Hello World\", NULL, NULL);\n        if (window == NULL) {\n                fprintf(stderr, \"Failed to create window.\\n\");\n                glfwTerminate();\n                return -1;\n        }\n        glfwMakeContextCurrent(window);\n\n        /* 初始化glad */\n        if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress))\n        {\n                fprintf(stderr, \"Failed to initialize GLAD\\n\");\n                glfwTerminate();\n                return -1;\n        }\n\n        /* prepare render */\n\n        /* main loop */\n\n        glfwTerminate();\n        return 0;\n}\n\n创建窗口的代码比较容易理解，到这里可以尝试编译一下代码检查有没有遇到什么问题，如果编译失败了可以尝试检查GLFW是否安装正确，代码哪里出现了什么问题。\n编译代码并运行生成的程序：\ncd build\ncmake .. &amp;&amp; make -j8\n./main\n\n如果一切正常的话，可以看到窗口一闪而过就消失了，因为到目前为止我们只创建了一个窗口，创建完成后就结束了程序，所以窗口会瞬间消失。\n\n准备绘图\n在绘制形状之前，我们需要一些准备工作比如设定视口、回调函数，创建顶点缓冲区等操作，然后在大循环中进行渲染绘制。\n视口\n首先要告诉OpenGL咱的窗口尺寸是多少，以便OpenGL根据窗口大小显示数据和坐标。\n在/* prepare render */处添加代码：\nglViewport(0, 0, 800, 600);\n\n首先需要知道你传给OpenGL的坐标都是-1.0到1.0之间的数，OpenGL再将其转换成屏幕上的像素点坐标，这个过程由GPU运算所得，所以你得告诉OpenGL你的屏幕尺寸，glViewport的前两个参数为0, 0指的是窗口左下角的位置，这个值咱目前不需要修改。\n回调函数\n我们需要一个窗口被更改的回调函数，这样当窗口尺寸发生变化时，程序可以调用这个函数调整视口。\n我们还需要一个按键回调函数，当用户按下键盘上的某个按键后会调用这个回调函数处理按键操作。\n编写函数framebuffer_size_callback用来处理窗口尺寸更改:\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n        glViewport(0, 0, width, height);\n}\n\n这样当你拖拽窗口进行缩放时，窗口里的图像也会跟着窗口尺寸改变而进行缩放。\n编写key_callback函数处理用户按键操作：\nvoid key_callback(GLFWwindow *window, int key, int s, int action, int m)\n{\n        if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) {\n                glfwSetWindowShouldClose(window, GL_TRUE);\n        }\n\n        if (key == GLFW_KEY_Q &amp;&amp; action == GLFW_PRESS) {\n                glfwSetWindowShouldClose(window, GL_TRUE);\n        }\n}\n\n当用户按下ESC或Q键时，可以结束OpenGL窗口的运行。\n然后我们需要注册这两个回调函数，在/* prepare render */处添加下面的代码:\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\nglfwSetKeyCallback(window, key_callback);\n\n大循环\n在大循环中，每循环一次代表绘制一帧画面。这里利用了双缓冲将绘制的图形放到缓存中，然后将缓存中的图形刷新到显示器上。(因为OpenGL绘图操作是逐行绘制的，如果不先将图形存到缓存中而直接显示在显示器上的话，在画面快速变动时你很可能会遇到画面撕裂，垂直不同步)\n大循环部分的代码长这个样子:\nwhile(!glfwWindowShouldClose(window))\n{\n        /* 清空背景色为深灰色 */\n        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        /* draw something */\n\n        /* swap buffer */\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n}\n\n每次循环的开始需要使用glClear清空屏幕，这样就不会看到上一次渲染的结果。\n这里我们使用glClearColor设定清空屏幕的颜色为接近纯黑色的灰色。\n大循环每循环一次，OpenGL就渲染了一帧画面并显示在显示器上，所以你可以计算一秒钟循环的次数而估算游戏的帧率。\n\n因为我们使用了双缓冲，所以这时游戏的帧数被限制为等于显示的刷新帧数，\n比如显示器刷新率为144帧，游戏的帧率就被锁为144，如果想解除这个限制需要改为单缓冲。\n\n\n到此为止，我们已经创建了一个游戏引擎，但是这个引擎还什么都没有做。\n尝试编译代码，可以看到一个黑色（深灰）的窗口，按ESC或Q即可结束运行。\n\n\n    \n\n\n如果你遇到什么问题，可以对照一下代码是否有问题。\n\n三角形\n画三角形的过程很简单，首先要确定三角形的三个顶点坐标，然后告诉GPU这三个点坐标就可以了 :)\n\n如果你看不懂顶点着色器、几何着色器、片段着色器、光栅化这些难懂的知识点，那么你不必急于弄懂这个过程，等把图形绘制出来后再回来看这部分的内容。\n\n标准化设备坐标\n因为OpenGL的坐标为都是-1.0f到1.0f之间的数（我们先不考虑视口变换这些复杂的情形）\nx, y, z的坐标为-1.0f到1.0f的坐标称作标准化设备坐标，坐标原点在窗口的正中央且在窗口的表面上，往右为x正方向，往上为y正方向，往屏幕里面为z正方向（这里是左手系）。\n有关标准化设备坐标的介绍请看这里。\n所以我们先声明三角形的顶点和颜色值到一个一维数组里面（用一维数组是因为顶点坐标值在内存的分布都是连续的，这样方便给GPU传坐标）。\nfloat vertices[] = {\n    -0.5f, -0.5f, 0.0f,     // 左下角\n     1.0f,  0.0f, 0.0f,     // red\n     0.5f, -0.5f, 0.0f,     // 右下角\n     0.0f,  1.0f, 0.0f,     // green\n     0.0f,  0.5f, 0.0f,     // y轴正上方\n     0.0f,  0.0f, 1.0f      // blue\n};\n\n顶点缓冲\n首先我们需要创建一个顶点缓冲对象，用来存我们的顶点信息，这个对象叫“Vertex Buffer Object”（VBO），之后创建一个顶点数组对象“Vertex Array Object”（VAO），用来存我们创建的VBO。\n为便于理解，你可以把VBO当作为开辟了一块GPU上的显存(Buffer)，用来存顶点和颜色信息，然后VAO是一个包含多个VBO的数组(Array)。\n绘图时可以把VBO中存的大量顶点信息发送给GPU，因为用CPU给显卡发顶点坐标的速度慢而且没办法一次发送大量的顶点坐标，所以我们把顶点坐标存到显存中，绘图时直接访问显存即可。\n生成一个VBO和一个VAO的代码为：\n// VAO和VBO的ID都是非负整型\nGLuint VBO, VAO;\n\n// 生成一个VAO和一个VBO\nglGenVertexArrays(1, &amp;VAO);\nglGenBuffers(1, &amp;VBO);\n\n我们刚刚创建好了一个缓存对象，我们现在需要告诉这个缓存的数据空间大小以及数据（顶点坐标）。\n首先我们绑定刚创建的VAO，然后绑定VBO\nglBindVertexArray(VAO);\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\n\n之后给VBO传递数组信息\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n\n第一个参数是目标缓冲的类型，我们刚刚把VBO绑定到GL_ARRAY_BUFFER上了\n\n第二个参数是顶点信息所占的空间大小，单位是字节。三角形一共3个顶点，每个顶点有3个坐标值和3个颜色值，\n所以大小是6 * 3 * sizeof(float)，不过我们可以直接用sizeof(vertices)知道整个数组的大小。\n\n第三个参数是数组的地址\n\n第四个参数告诉GL我们的顶点数据几乎不会改变，所以是GL_STATIC_DRAW。\n如果数据会被改变很多次，则为GL_DYNAMIC_DRAW\n如果数据每次绘制都会更改，则改为GL_STREAM_DRAW\n\n\n然后我们告诉CPU我们给VBO传递的数组都是什么：\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) 0);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) (3 * sizeof(float)));\nglEnableVertexAttribArray(0);\nglEnableVertexAttribArray(1);\n\n\n第一个参数为位置，告诉这个数据传递到顶点着色器的哪个位置上\n\n第二个参数为大小，我们定义的那个数组一个顶点有3个坐标，所以是3\n\n第三个参数为数据类型，这里是float。\n\n第四个参数为false，暂时不用管他\n\n第五个参数为步长，一个顶点有三个坐标和三个颜色值，所以每传一个顶点，就走6 * sizeof(float)的长度。\n\n第六个参数为偏移量，因为我们定义的数组中前三个数字代表顶点坐标，后三个数字代表颜色，所以传递顶点坐标时，偏移量为0，传递颜色时偏移量为3 * sizeof(float)。\n\n\n\n之后使用glEnableVertexAttribArray告诉OpenGL启用顶点着色器上这个位置的数据。\n最后使用完VAO后要记得将其解绑：\nglBindVertexArray(0);\n\n着色器\n我们需要写两个着色器程序，分别为顶点着色器和片段着色器。\n\n开头说的核心模式可编程管线就是指我们可以写着色器程序，手动指定管线都进行什么操作。\n\n顶点着色器\n因为OpenGL使用的是标准化设备坐标而不是屏幕上的像素点为坐标，所以GPU需要把标准化设备坐标转换为屏幕上的像素点，这个过程由顶点着色器实现。\n而顶点着色器不知道咱们三角形的每个顶点的坐标是多少，所以咱们得往着色器中传我们刚才创建的VBO里面存储的坐标。\n着色器程序使用GLSL编写，其代码和C很像\n在代码文件夹中新建一个vertex.glsl，编写以下代码：\n#version 330 core\nlayout (location = 0) in vec3 aPos;     // 传入坐标\nlayout (location = 1) in vec3 aColor;   // 传入颜色\nout vec3 color;     // 向片段着色器发送颜色\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0);\n    color = aColor;\n}\n\n\n第一行代表我们使用OpenGL 3.3 核心模式\n\n第二行声明了一个类型为vec3（三维坐标）的变量，该变量的位置为0，需要人为的通过这个位置给他传值，这个变量代表顶点的坐标\n\n第三行声明的aColor用来代表颜色，顶点着色器不需要处理颜色，所以我们接收到颜色值后不需要处理，直接传出去即可。\n\nmain函数中gl_Position代表这个顶点的位置坐标，我们把CPU传给顶点着色器的vec3转换为vec4。\n\n\n片段着色器\n顶点着色器处理完顶点后，由片段着色器计算每个像素点的颜色，所以如果我们想给三角形上色的话，也是在这个环节进行。\n在代码文件夹中新建一个fragment.glsl\n#version 330 core\nin vec3 color;    // 接收顶点着色器发送的颜色\nout vec4 FragColor;\n\nvoid main()\n{\n    FragColor = vec4(color, 1.0f);\n}\n\n\n第一行同顶点着色器，代表OpenGL版本为3.3 核心模式\n\n第二行表示接收顶点着色器发送的颜色数据到变量color\n\n第三行声明了一个类型为vec4(4维坐标)的变量，表示向外传递变量FragColor（该像素点的颜色值）\n\nmain函数中设定变量FragColor的值等于color，用来指颜色。\n最后一个值恒为1.0f，我们暂时不需要修改它。\n\n\n编译着色器\n因为我们只是写了着色器程序的代码，需要让GPU将其编译。\n编译着色器的部分对应的LearnOpenGL CN教程在这里，本篇不打算重复讲编译着色器部分的代码。\n我们可以把编译着色器的代码封装到几个函数里面，这样可以减少main函数中重复代码的数量。\n有关这部分的代码我推荐使用这篇文章中讲述的方式从文件中读取glsl代码并将其编译。\n最后在main函数的准备阶段处的最下面，插入以下代码，编译你的着色器程序：\nGLuint shaderProgram = load_program(\"vertex.glsl\", \"fragment.glsl\");\n\n我们期待的三角形\n经过了前面的一番准备，我们创建了缓冲对象存顶点的坐标和颜色信息，之后编写了着色器程序处理顶点坐标和颜色。\n现在我们终于可以在大循环中画三角形了。\n在大循环的/* draw something */下面添加如下代码：\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglBindVertexArray(0);\n\n这串代码表示我们首先使用刚编译好的着色器程序，之后绑定VAO，绘制一个三角形，最后解绑。\n\n至此我们的工程文件夹结构修改如下：\n├── build/\n├── CMakeLists.txt\n└── src/\n    ├── fragment.glsl\n    ├── glad.c\n    ├── main.c\n    ├── shader.c\n    ├── shader.h\n    └── vertex.glsl\n\n因为我们编写了vertex.glsl和fragment.glsl，需要修改CMakeLists.txt，使得编译时将代码文件夹下的着色器文件复制到build文件夹下。\n在CMakeLists.txt的find_package下面添加如下代码：\nconfigure_file(src/vertex.glsl vertex.glsl COPYONLY)\nconfigure_file(src/fragment.glsl fragment.glsl COPYONLY)\n\n编译后运行程序，可以看到一个五颜六色的三角形，它的左下角为红色，右下角为绿色，顶点为蓝色。\n\n    \n\n\n\n如果你遇到了问题，或者哪里不太明白，可以看咱写好的代码：\n\nmain.c\n\nshader.h\n\nshader.c\n\nvertex.glsl\n\nfragment.glsl\n\nCMakeLists.txt\n\n\n\n"},{"title":"Spring - 4","url":"/posts/spring-4/","content":"\n\n\n咱去年忘了更新这个系列...\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"愚カシイ机械\",\n        artist: \"岡部啓一 / 石濱翔 / 帆足圭吾 / 高田龍一\",\n        url: \"https://music.starry-s.me/music/f47cbf8a517c72c16b5eff614cd78ace.m4a\",\n        cover: \"https://music.starry-s.me/music/cover/2522279674184572.png\",\n        lrc: \"\",\n        theme: \"#aa6666\"\n    }]\n});\n \n\n\n前一阵子买了二手的适马17-50 f2.8镜头，在网上看这镜头很适合新手学摄影，而且这个焦段+大光圈适用的范围也很广。遂把在家吃灰了一年的相机带回学校，打算找时间拍点风景照片。\n实际上买完新镜头后我就拿它拍了几张花的照片后也没怎么出过门，本来打算5月初份去长白岛拍樱花的然而经过了五一小长假的调休，上周末的体侧，这周辽宁省又开始闹疫情，所以只好先拍点校内的风景啦。\n如果你想看长白岛的樱花，不妨看一下Spring - 3这篇文章。\n\n仅使用Raw Therapee和Adobe Lightroom对照片进行了裁剪并调整颜色，并由GIMP压缩\n\n\n\n\n\n\n拍摄自：2021-05-18\n\n在大风天拍蒲公英确实是个不明智的选择。\n\n\n\n\nSpring - 4\n"}]}