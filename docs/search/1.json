{"data":[{"title":"404 Not Found","url":"/404.html","content":"\n    \n\n\n\n    Image from https://http.cat.\n\n"},{"title":"About","url":"/about/","content":"\n\n\nAbout Me\n\n学生党, 新鲜韭菜, 野生Arch Linux用户一枚\n\n咱喜欢的游戏: Minecraft Java Edition, NieR:Automata, NieR:Replicant, Detroit: Become Human, Portal全系列; 除此之外咱还玩过Overwatch, PUBG, FGO, Don't Starve, 崩坏3等。\n\n咱喜欢的动漫/电影: 空之境界剧场版（推荐空境原著）、FSN &amp; FZ全系列、某科学的超电磁炮、君主·埃尔梅罗二世事件簿 魔眼收集列车 Grace note、声之形、秒速5厘米、利兹与青鸟、狼与香辛料。\n还看过格莱普尼尔、黑执事、几集新世纪福音战士和宝石之国和魔法禁书目录、我们从未知道那天所见的花的名字等。\n\n月厨, 空境剧场版看过无数遍, 原著看过一次后打算有时间再看一遍, 第一次读原著好多东西都没有看懂, FGO玩不懂算是个假月厨吧。\n\n咱喜欢摄影，有一台入门级半画幅单反，适马17-50mm f2.8和佳能50mm f1.8镜头。\n\n听歌种类略杂, 很少听华语。喜欢的歌以ACG系列为主, 首选Kalafina和梶浦由記的曲子以及尼尔/龙背系列。尽管不是东方厨但是东方的歌确实好听, 除此之外还听电音和轻音乐。\n\n常用Apple Music, 因为Apple Music有Kalafina的版权, 除此之外还经常用网易云音乐查找歌曲以及听日推\n\n偶尔在B站水视频, 是一名没有几个粉丝、几个月一更新的那种年更UP主, 不追求播放量和粉丝数,有人喜欢就很开心了。\n\n社交恐惧, 拖延, 情商低, 自我设障, 不过都太复杂了咱自己也讲不清楚（也不想弄清楚了, 不爱说话是真的\n\n不擅长交流，有些太复杂的东西又很难用文字表达出来\n\n不擅长制定并执行计划, 喜欢压力, 擅长拖延。\n\n菜, 很菜, 非常菜, 还懒, 不想努力, 肥, 宅, 新手, 不萌, 丑, 接近于废物一个。\n\n睡觉 睡觉 睡觉 睡觉 睡觉 睡觉 ZZZZZZZ~\n\n\nSTARRY-S' Blog\n建于2016年8月21日, 曾用域名starry-s.me、starry-s.xyz、starry-s.com和starry-s.cn。\n现用域名为starry-s.moe, 前两天给域名续费时因为误操作，导致我的.me域名被删掉了，因此我不得不再注册了一个moe域名。\n本站由Hikaru生成, 主题为ARIA, 托管于GitHub Pages（见页面右下角）, 很喜欢这个生成器以及ARIA这款主题。\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"尼尔机械纪元 Nier Automata - Soundtrack Medley\",\n        artist: \"Animenz\",\n        url: \"https://music.starry-s.moe/music/0f0e_0758_070b_8de6859a81025aae1e540aed59439f48.m4a\",\n        cover: \"https://music.starry-s.moe/music/cover/109951163092751719.jpg\",\n        lrc: \"\",\n        theme: \"#F6890E\"\n    }]\n});\n \n\n\n写于2020年8月16日凌晨, 随时更新。\n\n"},{"title":"归档","url":"/archives/","content":""},{"title":"分类","url":"/categories/","content":""},{"title":"首页","url":"/","content":""},{"title":"标签","url":"/tags/","content":""},{"title":"《空之境界》摘抄","url":"/posts/karanokyokai/","content":"\n\n很久以前就打算二刷空境原著了，由于种种原因进展一直比较缓慢。\n最终在 Kindle (泡面盖) 上阅读时标记了一些不错的菌言菌语，整理到博客上。\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"Oblivious\",\n        artist: \"Kalafina\",\n        url: \"https://music.starry-s.moe/music/obj_w5rDlsOJwrLDjj7CmsOj_8776653719_722d_c783_516e_072d631639c3a9e51d99be99dfae261f.m4a\",\n        cover: \"https://music.starry-s.moe/music/cover/Kalafina All Time Best 2008-2018 small.jpg\",\n        lrc: \"\",\n        theme: \"#7c7c7c\"\n    }]\n});\n \n\n俯瞰风景\n\n飞行这个名词，与坠落这个名词是相连结的。但越是迷恋天空的人，越会欠缺这样的认知，结果死了之后也只能持续朝云端飞行，不会往地面坠落下来，等于是朝着天空坠落。\n\n视野并不是眼球看到的景象，而是大脑处理过的景象。我们的视野受到我们的常识保护着，不认为自身的高度叫高，甚至觉得是种常识，没有高这个概念存在。反过来说，凡是人类，都活在俯瞰的视野中。\n\n人是活在箱中的生物，也只能在箱中生活。\n\n在这短暂存在的密室里，现在无论外界发生什么事都与式没有关联，也无法产生关联。这份实际感受，微微沁入她本应空虚的心。\n\n——如果自身的视野就是世界的一切，此刻世界的确正在沉睡。\n\n如果城市是深海，夜空就是纯粹的黑暗。在那片黑暗上，星辰就像散落的宝石那般闪闪发光。月亮是洞穴，一个凿穿夜空这张黑色图画纸的巨大洞穴。\n\n月亮其实不是反射太阳的镜子，只是在窥视这一侧的景色——在两仪家，式曾听人这么说过。\n\n一头宛如以一根根丝线梳就的黑发顺滑无比，只要风势一大，黑发迎风飞舞的模样就散发出无比幽玄之美。\n\n刀刃有六寸长，与其说是刀更像是一柄只由白刃构成的凶器。\n\n因为天空没有尽头。我认为如果能无拘无束的漫游、能自由飞往任何地方，就可以找到我不讨厌的世界。\n\n所谓的 ‘逃’ 有两种，漫无目的的逃以及带有目的的逃。一般将前者称为 ‘漂浮’，后者称为 ‘飞行’。\n\n我们并不是根据背负的罪来选择道路，而是先选择道路再背负起自己的罪孽。\n\n虽然根本不值得一提，我终究认为自己最后还是应该死于从俯瞰坠落。\n\n无论当事人下了什么决定，自杀还是会被视为自杀来处理。\n\n\n\n杀人考察（前）\n\n人要无知一点比较好，黑桐。人在小时候只看得到自己，根本不会察觉别人的恶意。就算是污秽也好，当被爱的感觉转化成经验，人才能够以善意去对待他人——因为人只能展现本身已具有的情感。\n\n你要当心点，黑桐同学。不详的预感，会招来不详的现实\n\n\n\n痛觉残留\n\n无法适应社会的人非常多，他们的存在本身却从一开始就无法适应这个社会。他们不应该存在，不，是无法存在。\n\n这让她很高兴。因为活下去，就等于痛苦下去。\n\n被排除在境界之外的人，也会被彻底剥夺其存在意义。所以，那只不过是肉块罢了。\n\n对于想不通的事，不要强迫自己接受比较好。\n\n因为缺乏感觉的人一样拥有身体，也能够移动自如，我们就认为他们除了没有感觉之外没什么不同。但这是错误的。没有感觉，就代表什么都接收不到喔，黑桐。\n\n黑桐没能赶上是吗？接下来，就看暴风雨是先抵达，还是先被制造出来。式一个人去，有可能反被打败啊，两仪。\n\n痛觉可是种好东西，有错的终究是伤口，不可以搞错先后顺序。我们需要痛觉，无论多么痛苦都一样。\n\n“没有什么伤是无法痊愈的。不会痊愈的伤口不叫伤口，叫作死亡。”\n\n\n\n伽蓝之洞\n\n“没错，你无法过着正常生活。要烦恼也该有个限度，两仪式，你该认清现实了。你原本就是属于我们这边的人吧？ 所以——别再梦想什么普通（幸福）的生活了。”\n\n这女的——真是专挑我逃避的问题刺人痛楚。\n\n\n\n矛盾螺旋\n\n所谓的变成大人，就是明智的将幻想取代。\n\n追求社会上理所当然的生活就得遭受打击。只要接受我的人生注定如此，就不会觉得自己不幸。这和小时候一样。我以聪明代替幻想，决定一个人活下去。\n\n这家伙以前曾说心是看不见的。因此，她绝不会对别人吐露肉眼看不见的烦恼。\n\n忍耐明明是你的优点，结果你却选择了痛苦的那条路。第一次见面的时候，胭条巴正要抹杀胭条巴。失去未来，变成空壳的你，也跟现在一样想死是吗？\n\n或许，她就是将如暗处鲜花般优美的日本幽灵，与外国童话中的妖精融合而成的结晶。\n\n“和他们结识，算是我在伦敦时唯一的疏忽吧。”\n\n灵长已经变得太复杂，是过度追求万能，替生命附加种种能力导致的结果。\n\n朦胧不定的东西会召唤朦胧不定的言语。事情明明这么简单，方才的平稳气息却已散去，让人难以呼吸。\n\n由于没有任何一点小的异常，所以也就注意不到大的异常。\n\n若不在人们身上使用相同的仪式死亡，给你的献祭便不完全。如果死亡之后再次复活的螺旋不完全。没有达到相互交缠且相克的条件，便无法将其联系起来。于是我便准备了他们的尸体作为阴，他们平常的生活作为阳。\n\n死者与生者无法兼容。在满是矛盾的这个世界中，个体是没有共通这层意义的。\n\n第一次脱离了死的困境，但那只不过是为了迎接第二次、第三次的死所注定的方法。这种有限的死的方式。\n\n为了消除现象而引起的现象，最终会变成将自己向绝境逼迫的行为。但是果然，即使留下最初的现象不管，也会演变成被逼迫至绝境的情形。无论怎样努力，现象这个词的含义是不会消失的。\n\n由于事物总是连带有许多阻碍，所以并不存在完美的事物。\n\n“学问和年龄无关，柯尼勒斯，虽然你外表看起来很年轻，但你总是只注意外表，所以内在才会追不上啊。”\n\n让一个人了解事物，与其教他，不如让他自己体验来得快。\n\n生命的证据不是如何去追求快乐，因为生命的意义，就是要去体会痛苦。\n\n但那也是不可能的，扭曲的轮回不会在同一个地方转动，若死者不能亲自结束身为死者的存在，日常生活永远不会到来。\n\n\n\n忘却录音\n\n事情就是因为有尽头，所以才能观测到无限这件事。\n\n在确认自己的记忆时，不可以依靠他人的记忆。毕竟只有名为回忆的自我天平，才能决定过去......\n\n所谓的忘记，其实是记忆劣化。回忆是一种不会消失、只会逐渐褪色的废弃物。你不觉得很可惜吗？人们竟然让属于永恒的事物生锈。亲手让身为永恒的事物化为烟尘。\n\n污秽由污秽自己解决是最好的作法，因为不管是什么人，想要清除污秽，就一定会受到污秽沾染，这是一个不详的循环，我们称之为 ‘诅咒’。\n\n所谓的天才，到最后只是把自己当成对手。\n\n妖精很难控制，操纵者常常在不知不觉间，从实现他们自己的愿望变成实现妖精的愿望。鲜花你听清楚了，要注意——使用自己以外的东西所制造出来的使魔，别走到操纵者反被操纵的下场\n\n我的能力只能从别人已经走过的道路来获得信息，但你却可以看到接下来的路通往哪里呢......\n\n人之所以选择忘却记忆，绝不是因为那些记忆没有必要，而是因为记住那些事很危险。\n\n我们刻意忘却过去犯下的种种过错。忘却那些如果记得就会让自己崩溃的记忆。我们靠着这么做——才能守护自己现在是健康而无辜的幻象。\n\n“物质是用来消费及磨耗的事物，这个名为地球的世界逐渐走向崩坏也是自然的道理，因为在最后走向死亡是最正确的存在方式，所以谁也不会去解决这个问题。对我们来说，真正的世界只存在于各自的脑髓中而已。”\n\n\n\n杀人考察（后）\n\n本能在表层意识具现化成人格时，将会驱逐所有理性，会凌驾我这个名为白纯里绪的人格。\n\n向对方抱有的情感，超出自己的容许量的时候吧，自己能承受的感情量是一定的，有些人容量很大，也有人容量很小，不论是爱情或者是憎恨，当那种感情超过自己所能容纳的量，那么超出的部分会转变为痛苦，如此一来，便不能忍受对方的存在。\n\n为了到最后让自己死去，所以我们只有杀一次人的权利。\n\n人一辈子只能承受一人份的人生价值，为了原谅无法走到尽头的人生，所以大家才会用尊重的态度看待死亡，因为生命等价，即使是自己的生命，也不是自己所拥有的东西。\n\n光是孕育意识的大脑，无法产生人格。虽然只有脑部也可以活下去，但我们必须先拥有肉体才能产生自我意识。有了肉体之后，和肉体一起培养，就有了现在的人格。喜爱自己肉体的人，应该属于社交型人格，而厌恶自己肉体的人，则属于内向型人格。虽然光有意识也可以培养出人格，但那样的人格是无法认识自己的，一般来说，心灵就会长成特别的东西。那样的话，已经不能称之为人格，和计算机没有什么不同。如果有谁只是一个大脑，那个人就必须创造出一个 ‘只有脑的自己’ 的人格。必须舍弃肉体这个大我，而保存意识这个小我。\n\n“不是有了知性才有肉体。”\n“而是，有了肉体之后，知性才得以诞生。”\n\n说到底，人类只不过是在自己这个空壳中做着梦而已。明明是那么地显而易见的。\n\n大部分的人并不是出于自己的愿望要过那样的生活。想要成为特别的存在却无法实现，这种形式才是真正的平凡人生。\n\n\n\n未来福音\n\n她擅长的并非预测未来，而是教人如何避免遭遇到不幸。\n\n那是一种希望，希望对方相信她说的话。也是一种绝望，绝望于对方不可能相信。\n\n所谓的现实，即为数值尚未确定的公式。公式的数值会不断变动，不用说是求出答案，人们连要求出什么都不知道。然而——一旦这个数值确定下来，答案便再也不会改变。\n\n这一切都是醒着的，但没有什么活着的样子。没有任何例外。\n\n“就是因为知道得太清楚，才会看不见吗——橙子说得对极了。炸弹魔，你有没有听到？既然你的眼睛什么都没看见，不如废了算了。”\n\n“未来并没有不同。‘未来’这种东西，一开始便不存在。不存在的东西，当然没有办法控制。”\n\n她依然是老样子，即使自己遇到不幸，也没有显露出来，仍旧表现得潇洒又懒惰，完全就是时下高中女生会有的样子。\n\n“没错。那顶多算是憧憬。你就像个看到偶像，拼命叫个不停的幸福小粉丝。所谓的恋爱啊，应该要更轰轰烈烈、更不堪回首、更捉摸不定，如同不是抵达终点，便是发生意外的云霄飞车。总之啊，谈恋爱不可能留下什么美好回忆......”\n\n“我漂亮地踩到地雷。”\n\n既然我可以用未来视取巧，相对地当然要承担一些代价。\n\n不论谁看见她，都会期待她未来的发展，另一方面，又暗暗希望她永远维持现在的样子\n\n在这个时代，幸福的未来相当罕见。\n\n既然看得见未来，当然也会了解过去。\n\n这十年——不，说得更正确，是十二年来，我始终像故事中模仿人类的机器人，融入这个城市的生活罢了。\n\n我遇见难得的朋友，之后又失去他。尽管试着承续他的衣钵，却每天被唯一的读者批评。\n\n尽管我也为此付出代价，往后的人生满是失败。但我至少还留有什么。\n\n“你很快会从这个世界上消失。你的前途一片漆黑，未来完全没有任何希望。你不会留下任何东西，也没有获救的可能......但是，太不可思议了，尽管如此，你的梦想将继续活下去。”\n\n\n\n"},{"title":"Learn OpenGL","url":"/posts/learn_opengl/","content":"\n\n其实咱很久很久以前就开始看LearnOpenGL CN这个网站了......\n\n\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"One Light\",\n        artist: \"Kalafina\",\n        url: \"https://music.starry-s.moe/music/obj_w5rDlsOJwrLDjj7CmsOj_8776656540_d358_942f_cb9c_b29cfa734f2c6c5f95938d794ce3d90e.mov\",\n        cover: \"https://music.starry-s.moe/music/cover/Kalafina All Time Best 2008-2018 small.jpg\",\n        lrc: \"\",\n        theme: \"#484444\"\n    }]\n});\n \n\n前言\n首先需要明白什么是核心模式，什么是立即渲染模式，立即渲染模式的代码中都包含glBegin()和glEnd()，绘图的部分都是在这两个函数之间，比如画一个点就是glVertex2f(x, y)，这种方式画图确实很简单，用户只要提供坐标和颜色就好了，不用知道GPU干了什么，而缺点是性能低，有很多限制，所以新版本的OpenGL为了给开发者提供更多的可操作空间而逐渐废弃了立即渲染改用核心模式。\n核心模式提供了很多强大的功能，可以管线编程，代码量增加了很多，所以对初学者不太友好。\nLearnOpenGL CN上面的代码基于C++，而OpenGL是用C编写的，教程上的代码除了矩阵运算部分可以使用C++的运算符重载而使代码编写起来变得更简单一些外，其他部分基本没啥区别，而且教程为了便于教学使用的也是面向过程式编程，没有将各个功能封装到一个类里面，所以咱这篇教程用C编写。\n要记住C就是C，C++就是C++，C不是C++的子集，只能说C++兼容部分C的代码，不要把C和C++混用，不要因为C++支持面向对象使得一些功能看起来简单很易于使用就轻易迈入C++的坑。\n准备工作\n有关OpenGL的介绍以及安装GLFW、GLAD以及编译所需的CMake的部分可以直接看教程，咱尽可能把教程上没有提到的或者是刚开始学OpenGL很难理解的部分记录下来。\n大体上就是安装glfw，Arch Linux使用包管理器sudo pacman -S glfw-x11 (如果你使用的是wayland，那么安装glfw-wayland)，然后把下载的glad/glad.h复制到/usr/include下，把glad.c复制到工程文件夹的代码目录下。\n为使用CMake生成Makefile，编写CMakeLists.txt:\ncmake_minimum_required(VERSION 3.0)\n\nproject(\n    \"Learn OpenGL\"\n    LANGUAGES C\n    VERSION 0.1.0\n)\n\nset(C_FLAGS \"-Wall -lm -ldl -std=c11\")\nset(CMAKE_C_FLAGS ${C_FLAGS})\nset(OpenGL_GL_PREFERENCE LEGACY)\n\nfind_package(glfw3 REQUIRED)\nfind_package(OpenGL REQUIRED)\n\ninclude_directories(${OPENGL_INCLUDE_DIR} src)\n\naux_source_directory(\"src\" GLSRC)\nadd_executable(main ${GLSRC})\ntarget_link_libraries(main ${OPENGL_gl_LIBRARY} glfw)\n\n完成上述步骤后，确保工程文件夹的结构如下：\n├── build/\n├── CMakeLists.txt\n└── src/\n    ├── glad.c\n    └── main.c\n\n创建窗口\n编辑main.c，加入所需的头文件\n\n#include \n#include \n\" data-info=\"language-C\" data-lang=\"C\" class=\"code-block\">// glad.h要加在glfw3.h之前\n\n#include &lt;glad/glad.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;stdio.h&gt;\n\n在main函数中初始化OpenGL并创建窗口\nint main(int argc, char **argv)\n{\n        glfwInit();\n        /* 使用OpenGL版本为3.3 */\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n        /* 使用核心模式 */\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n        /* 创建窗口 */\n        GLFWwindow *window =\n                    glfwCreateWindow(800, 600, \"Hello World\", NULL, NULL);\n        if (window == NULL) {\n                fprintf(stderr, \"Failed to create window.\\n\");\n                glfwTerminate();\n                return -1;\n        }\n        glfwMakeContextCurrent(window);\n\n        /* 初始化glad */\n        if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress))\n        {\n                fprintf(stderr, \"Failed to initialize GLAD\\n\");\n                glfwTerminate();\n                return -1;\n        }\n\n        /* prepare render */\n\n        /* main loop */\n\n        glfwTerminate();\n        return 0;\n}\n\n创建窗口的代码比较容易理解，到这里可以尝试编译一下代码检查有没有遇到什么问题，如果编译失败了可以尝试检查GLFW是否安装正确，代码哪里出现了什么问题。\n编译代码并运行生成的程序：\ncd build\ncmake .. &amp;&amp; make -j8\n./main\n\n如果一切正常的话，可以看到窗口一闪而过就消失了，因为到目前为止我们只创建了一个窗口，创建完成后就结束了程序，所以窗口会瞬间消失。\n\n准备绘图\n在绘制形状之前，我们需要一些准备工作比如设定视口、回调函数，创建顶点缓冲区等操作，然后在大循环中进行渲染绘制。\n视口\n首先要告诉OpenGL咱的窗口尺寸是多少，以便OpenGL根据窗口大小显示数据和坐标。\n在/* prepare render */处添加代码：\nglViewport(0, 0, 800, 600);\n\n首先需要知道你传给OpenGL的坐标都是-1.0到1.0之间的数，OpenGL再将其转换成屏幕上的像素点坐标，这个过程由GPU运算所得，所以你得告诉OpenGL你的屏幕尺寸，glViewport的前两个参数为0, 0指的是窗口左下角的位置，这个值咱目前不需要修改。\n回调函数\n我们需要一个窗口被更改的回调函数，这样当窗口尺寸发生变化时，程序可以调用这个函数调整视口。\n我们还需要一个按键回调函数，当用户按下键盘上的某个按键后会调用这个回调函数处理按键操作。\n编写函数framebuffer_size_callback用来处理窗口尺寸更改:\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n        glViewport(0, 0, width, height);\n}\n\n这样当你拖拽窗口进行缩放时，窗口里的图像也会跟着窗口尺寸改变而进行缩放。\n编写key_callback函数处理用户按键操作：\nvoid key_callback(GLFWwindow *window, int key, int s, int action, int m)\n{\n        if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) {\n                glfwSetWindowShouldClose(window, GL_TRUE);\n        }\n\n        if (key == GLFW_KEY_Q &amp;&amp; action == GLFW_PRESS) {\n                glfwSetWindowShouldClose(window, GL_TRUE);\n        }\n}\n\n当用户按下ESC或Q键时，可以结束OpenGL窗口的运行。\n然后我们需要注册这两个回调函数，在/* prepare render */处添加下面的代码:\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\nglfwSetKeyCallback(window, key_callback);\n\n大循环\n在大循环中，每循环一次代表绘制一帧画面。这里利用了双缓冲将绘制的图形放到缓存中，然后将缓存中的图形刷新到显示器上。(因为OpenGL绘图操作是逐行绘制的，如果不先将图形存到缓存中而直接显示在显示器上的话，在画面快速变动时你很可能会遇到画面撕裂，垂直不同步)\n大循环部分的代码长这个样子:\nwhile(!glfwWindowShouldClose(window))\n{\n        /* 清空背景色为深灰色 */\n        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        /* draw something */\n\n        /* swap buffer */\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n}\n\n每次循环的开始需要使用glClear清空屏幕，这样就不会看到上一次渲染的结果。\n这里我们使用glClearColor设定清空屏幕的颜色为接近纯黑色的灰色。\n大循环每循环一次，OpenGL就渲染了一帧画面并显示在显示器上，所以你可以计算一秒钟循环的次数而估算游戏的帧率。\n\n因为我们使用了双缓冲，所以这时游戏的帧数被限制为等于显示的刷新帧数，\n比如显示器刷新率为144帧，游戏的帧率就被锁为144，如果想解除这个限制需要改为单缓冲。\n\n\n到此为止，我们已经创建了一个游戏引擎，但是这个引擎还什么都没有做。\n尝试编译代码，可以看到一个黑色（深灰）的窗口，按ESC或Q即可结束运行。\n\n\n    \n\n\n如果你遇到什么问题，可以对照一下代码是否有问题。\n\n三角形\n画三角形的过程很简单，首先要确定三角形的三个顶点坐标，然后告诉GPU这三个点坐标就可以了 :)\n\n如果你看不懂顶点着色器、几何着色器、片段着色器、光栅化这些难懂的知识点，那么你不必急于弄懂这个过程，等把图形绘制出来后再回来看这部分的内容。\n\n标准化设备坐标\n因为OpenGL的坐标为都是-1.0f到1.0f之间的数（我们先不考虑视口变换这些复杂的情形）\nx, y, z的坐标为-1.0f到1.0f的坐标称作标准化设备坐标，坐标原点在窗口的正中央且在窗口的表面上，往右为x正方向，往上为y正方向，往屏幕里面为z正方向（这里是左手系）。\n有关标准化设备坐标的介绍请看这里。\n所以我们先声明三角形的顶点和颜色值到一个一维数组里面（用一维数组是因为顶点坐标值在内存的分布都是连续的，这样方便给GPU传坐标）。\nfloat vertices[] = {\n    -0.5f, -0.5f, 0.0f,     // 左下角\n     1.0f,  0.0f, 0.0f,     // red\n     0.5f, -0.5f, 0.0f,     // 右下角\n     0.0f,  1.0f, 0.0f,     // green\n     0.0f,  0.5f, 0.0f,     // y轴正上方\n     0.0f,  0.0f, 1.0f      // blue\n};\n\n顶点缓冲\n首先我们需要创建一个顶点缓冲对象，用来存我们的顶点信息，这个对象叫“Vertex Buffer Object”（VBO），之后创建一个顶点数组对象“Vertex Array Object”（VAO），用来存我们创建的VBO。\n为便于理解，你可以把VBO当作为开辟了一块GPU上的显存(Buffer)，用来存顶点和颜色信息，然后VAO是一个包含多个VBO的数组(Array)。\n绘图时可以把VBO中存的大量顶点信息发送给GPU，因为用CPU给显卡发顶点坐标的速度慢而且没办法一次发送大量的顶点坐标，所以我们把顶点坐标存到显存中，绘图时直接访问显存即可。\n生成一个VBO和一个VAO的代码为：\n// VAO和VBO的ID都是非负整型\nGLuint VBO, VAO;\n\n// 生成一个VAO和一个VBO\nglGenVertexArrays(1, &amp;VAO);\nglGenBuffers(1, &amp;VBO);\n\n我们刚刚创建好了一个缓存对象，我们现在需要告诉这个缓存的数据空间大小以及数据（顶点坐标）。\n首先我们绑定刚创建的VAO，然后绑定VBO\nglBindVertexArray(VAO);\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\n\n之后给VBO传递数组信息\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n\n第一个参数是目标缓冲的类型，我们刚刚把VBO绑定到GL_ARRAY_BUFFER上了\n\n第二个参数是顶点信息所占的空间大小，单位是字节。三角形一共3个顶点，每个顶点有3个坐标值和3个颜色值，\n所以大小是6 * 3 * sizeof(float)，不过我们可以直接用sizeof(vertices)知道整个数组的大小。\n\n第三个参数是数组的地址\n\n第四个参数告诉GL我们的顶点数据几乎不会改变，所以是GL_STATIC_DRAW。\n如果数据会被改变很多次，则为GL_DYNAMIC_DRAW\n如果数据每次绘制都会更改，则改为GL_STREAM_DRAW\n\n\n然后我们告诉CPU我们给VBO传递的数组都是什么：\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) 0);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) (3 * sizeof(float)));\nglEnableVertexAttribArray(0);\nglEnableVertexAttribArray(1);\n\n\n第一个参数为位置，告诉这个数据传递到顶点着色器的哪个位置上\n\n第二个参数为大小，我们定义的那个数组一个顶点有3个坐标，所以是3\n\n第三个参数为数据类型，这里是float。\n\n第四个参数为false，暂时不用管他\n\n第五个参数为步长，一个顶点有三个坐标和三个颜色值，所以每传一个顶点，就走6 * sizeof(float)的长度。\n\n第六个参数为偏移量，因为我们定义的数组中前三个数字代表顶点坐标，后三个数字代表颜色，所以传递顶点坐标时，偏移量为0，传递颜色时偏移量为3 * sizeof(float)。\n\n\n\n之后使用glEnableVertexAttribArray告诉OpenGL启用顶点着色器上这个位置的数据。\n最后使用完VAO后要记得将其解绑：\nglBindVertexArray(0);\n\n着色器\n我们需要写两个着色器程序，分别为顶点着色器和片段着色器。\n\n开头说的核心模式可编程管线就是指我们可以写着色器程序，手动指定管线都进行什么操作。\n\n顶点着色器\n因为OpenGL使用的是标准化设备坐标而不是屏幕上的像素点为坐标，所以GPU需要把标准化设备坐标转换为屏幕上的像素点，这个过程由顶点着色器实现。\n而顶点着色器不知道咱们三角形的每个顶点的坐标是多少，所以咱们得往着色器中传我们刚才创建的VBO里面存储的坐标。\n着色器程序使用GLSL编写，其代码和C很像\n在代码文件夹中新建一个vertex.glsl，编写以下代码：\n#version 330 core\nlayout (location = 0) in vec3 aPos;     // 传入坐标\nlayout (location = 1) in vec3 aColor;   // 传入颜色\nout vec3 color;     // 向片段着色器发送颜色\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0);\n    color = aColor;\n}\n\n\n第一行代表我们使用OpenGL 3.3 核心模式\n\n第二行声明了一个类型为vec3（三维坐标）的变量，该变量的位置为0，需要人为的通过这个位置给他传值，这个变量代表顶点的坐标\n\n第三行声明的aColor用来代表颜色，顶点着色器不需要处理颜色，所以我们接收到颜色值后不需要处理，直接传出去即可。\n\nmain函数中gl_Position代表这个顶点的位置坐标，我们把CPU传给顶点着色器的vec3转换为vec4。\n\n\n片段着色器\n顶点着色器处理完顶点后，由片段着色器计算每个像素点的颜色，所以如果我们想给三角形上色的话，也是在这个环节进行。\n在代码文件夹中新建一个fragment.glsl\n#version 330 core\nin vec3 color;    // 接收顶点着色器发送的颜色\nout vec4 FragColor;\n\nvoid main()\n{\n    FragColor = vec4(color, 1.0f);\n}\n\n\n第一行同顶点着色器，代表OpenGL版本为3.3 核心模式\n\n第二行表示接收顶点着色器发送的颜色数据到变量color\n\n第三行声明了一个类型为vec4(4维坐标)的变量，表示向外传递变量FragColor（该像素点的颜色值）\n\nmain函数中设定变量FragColor的值等于color，用来指颜色。\n最后一个值恒为1.0f，我们暂时不需要修改它。\n\n\n编译着色器\n因为我们只是写了着色器程序的代码，需要让GPU将其编译。\n编译着色器的部分对应的LearnOpenGL CN教程在这里，本篇不打算重复讲编译着色器部分的代码。\n我们可以把编译着色器的代码封装到几个函数里面，这样可以减少main函数中重复代码的数量。\n有关这部分的代码我推荐使用这篇文章中讲述的方式从文件中读取glsl代码并将其编译。\n最后在main函数的准备阶段处的最下面，插入以下代码，编译你的着色器程序：\nGLuint shaderProgram = load_program(\"vertex.glsl\", \"fragment.glsl\");\n\n我们期待的三角形\n经过了前面的一番准备，我们创建了缓冲对象存顶点的坐标和颜色信息，之后编写了着色器程序处理顶点坐标和颜色。\n现在我们终于可以在大循环中画三角形了。\n在大循环的/* draw something */下面添加如下代码：\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglBindVertexArray(0);\n\n这串代码表示我们首先使用刚编译好的着色器程序，之后绑定VAO，绘制一个三角形，最后解绑。\n\n至此我们的工程文件夹结构修改如下：\n├── build/\n├── CMakeLists.txt\n└── src/\n    ├── fragment.glsl\n    ├── glad.c\n    ├── main.c\n    ├── shader.c\n    ├── shader.h\n    └── vertex.glsl\n\n因为我们编写了vertex.glsl和fragment.glsl，需要修改CMakeLists.txt，使得编译时将代码文件夹下的着色器文件复制到build文件夹下。\n在CMakeLists.txt的find_package下面添加如下代码：\nconfigure_file(src/vertex.glsl vertex.glsl COPYONLY)\nconfigure_file(src/fragment.glsl fragment.glsl COPYONLY)\n\n编译后运行程序，可以看到一个五颜六色的三角形，它的左下角为红色，右下角为绿色，顶点为蓝色。\n\n    \n\n\n\n如果你遇到了问题，或者哪里不太明白，可以看咱写好的代码：\n\nmain.c\n\nshader.h\n\nshader.c\n\nvertex.glsl\n\nfragment.glsl\n\nCMakeLists.txt\n\n\n\n"}]}